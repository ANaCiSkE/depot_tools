import collections
import cStringIO
import grammar
import pprint
import tokenize


class Value(object):
  pass

class Comment(object):
  def __init__(self, token):
    self.value = token[1]

  def Format(self):
    return [self.value]


class String(Value):
  def __init__(self, token):
    self.value = token[1]

  def __hash__(self):
    return hash(self.value)

  def __eq__(self, other):
    if isinstance(other, String):
      return self.value == other.value
    return self.value == other

  def Format(self):
    return ['\'' + self.value + '\'']


class List(collections.MutableSequence, Value):
  def __init__(self, tokens):
    self.tokens = tokens
    self.values = [
        position
        for position, token in enumerate(tokens)
        if not isinstance(token, Comment)
    ]

  def __getitem__(self, index):
    return self.tokens[self.values[index]]

  def __setitem__(self, index, value):
    assert isinstance(value, Value)
    self.tokens.append(value)
    self.values.append(len(self.tokens) - 1)

  def __delitem__(self, index):
    index = self.values[index]
    del self.values[index]
    del self.tokens[index]
    for i in range(index, len(self.values)):
      self.values[i] -= 1

  def __len__(self):
    return len(self.values)

  def insert(self, index, value):
    assert isinstance(value, Value)
    self.tokens.insert(self.values[index], value)
    self.values.insert(index, self.values[index])
    for i in range(index + 1, len(self.values)):
      self.values[i] += 1

  def Format(self):
    answer = ['[']
    for token in self.tokens:
      token_lines = token.Format()
      token_lines[-1] += ','
      answer.extend(['  ' + line for line in token_lines])
    answer.append(']')
    return answer


class Tuple(List):
  def Format(self):
    answer = ['(']
    for token in self.tokens:
      answer.extend(['  ' + line for line in token.Format()])
    answer.append(')')
    return answer


class Dict(collections.MutableMapping, Value):
  def __init__(self, tokens):
    self.tokens = tokens
    self.values = {}
    for pos, token in enumerate(tokens):
      if isinstance(token, Comment):
        continue
      key = token[1][0]
      if key in self.values:
        raise Exception('Duplicated key %s' % key)
      self.values[key] = pos

  def __getitem__(self, key):
    return self.values[key]

  def __setitem__(self, key, value):
    assert isinstance(value, Value)
    if key in self.values:
      self.tokens[self.values[key]] = value
    else:
      assert isinstance(key, Value)
      self.tokens.append((key, value))
      self.values[key] = len(self.tokens) - 1

  def __delitem__(self, key):
    del self.tokens[self.values[key]]
    key_pos = self.values[key]
    del self.values[key]
    for key, pos in self.values.iteritems():
      if pos >= key_pos:
        self.values[key] -= 1

  def __iter__(self):
    return iter(self.values)

  def __len__(self):
    return len(self.values)

  def Format(self):
    answer = ['{']
    for token in self.tokens:
      if isinstance(token, Comment):
        answer.append('  ' + ''.join(token.Format()))
      else:
        value_lines = token[1][1].Format()
        value_lines[-1] += ','
        lead_line = '  %s: %s' % (
            ''.join(token[1][0].Format()), value_lines[0])
        answer.append(lead_line)
        answer.extend(['  ' + line for line in value_lines[1:]])
    answer.append('}')
    return answer

def GenerateTokens(contents):
  return [
      token
      for token in tokenize.generate_tokens(
          cStringIO.StringIO(contents).readline)
      if token[0] not in {tokenize.NEWLINE, tokenize.NL}
  ]


def Parse(contents):
  ctx = grammar.GetPythonLikeContext()
  ctx.transform = True
  ctx.transformers.update({
      'name': String,
      'comment': Comment,
      'string': lambda ts: String((ts, ''.join(ts))),
      'dict': Dict,
      'list': List,
      'tuple': Tuple,
      'start': Dict,
  })

  tokens = GenerateTokens(contents)
  result, index, err = ctx.Parse(tokens)
  if err:
    print '\n'.join(err)
  else:
    print '\n'.join(result.Format())

test = """\
# Big
# Block
# Of
# Copyright

deps = {
  'src/v8': {
    'url': '{chromium_git}/v8/v8.git',
    'revision': '{v8_revision}',
  },
  # Some comment on src-internal
  'src-internal': {
    'url': 'https://chrome-internal.googlesource.com/src',
    'revision': 'fake_revision',
    'condition': 'checkout_ios',
  },
  'src/webrtc': Var('webrtc_git') + '/src.git' + '@' + 'some_revision',
  'src/something': {
    'packages': [
      {
        # Some comment on fake_package
        'package': 'fake_package',
        'version': 'version:3.0',
      },
    ],
    'condition': 'checkout_android',
  },
}

vars = {
  # Some comment
  'chromium_git': 'https://chromium.googlesource.com',
  'v8_revision': 'deadbeef',
}
"""

test = """\
deps = {
  "hola": Var("hello") + "world",
  # hello
  # world
  "mundo": "world",
  # lemur
}
"""

test = open("../../../chromium/src/DEPS").read()

Parse(test)
